function vesicledetect_quick(RAMONVol, template, annoId, neighborhood_size, neighbor_dist, thresh, data_set, padX, padY, padZ, outFile)
% Function to identify neurotransmitter-containing vesicles using a template
%
% **Inputs**
%
%	RAMONVol: (string)
%		- Location of mat file containing an image matrix stored in a RAMONVolume named cube.
%
%	template: (string)
%		- Path to file containing template extracted from this dataset
%
%	neighborhood_size: (uint)
%		- Size of neighborhood for algorithm
%
%	neighborhood_dist: (uint)
%		- Distance used in suppressing isolated detections
%
%	thresh: (uint)
%		- Threshold used for determining whether a correlation response is strong enough to return a vesicle at that location
%
%	data_set: (uint)
%		- Dataset parameters (used to convert to raw image size values).  0: kasthuri11, 1: bock11
%
% padX (uint)
%   - Number representing value to crop the output volume in the x dimension.
%
% padY (uint)
%   - Number representing value to crop the output volume in the y dimension.
%
% padZ (uint)
%   - Number representing value to crop the output volume in the z dimension.
%
%% outFile: (string)
%   - String specifying the full path and file name for the output of the vesicle detection algorithm (RAMONVolume saved to disk).
%
% **Outputs**
%
%	No explicit outputs.  Output file is saved to disk rather than
%	output as a variable to allow for downstream integration with LONI.
%
% **Notes**
%
% Test call
% vesicle_detect_quick(im,'~/code/vesicle/data/vesicle_templates_kasthuri11cc.mat',1, 3,120,1.25,0,50,50,2,'testv.mat')


% Load data volume
if ischar(RAMONVol)
    load(RAMONVol) %should be saved as cube
else
    cube = RAMONVol;
end

data = cube.data;
tail = []; % used to estimate threshold

%% Check inputs
if ~exist('template','var')
    error('vesicle_detect:param_error','You must provide a template generated by "get_template.m"');
end

%% Load Template
load(template);

emptyFlag = 0;
%% Run Correlation
[x,y,z] = size(data);

mean_template = mean(patches,3);
[x_template,y_template] = size(mean_template);

matches = zeros(x+x_template-1,y+y_template-1,z);
h = fspecial('log',[x_template y_template],.5);
for ii = 1:z
    % Correlation
    matches(:,:,ii) = normxcorr2(mean_template,data(:,:,ii));
    % LoG
    matches(:,:,ii) = imfilter(imcomplement(matches(:,:,ii)),h,'replicate');
end

% Crop back to image
matches(:,1:floor(y_template/2),:) = [];
matches(1:floor(x_template/2),:,:) = [];
matches(:,end-floor(y_template/2)+1:end,:) = [];
matches(end-floor(x_template/2)+1:end,:,:) = [];


% Threshold
if ~isempty(tail)
    matches(matches<0) = 0;
    [counts,x] = hist(matches(:),128);
    totals = cumsum(counts);
    percent = (totals(end) - totals) ./ totals(end);
    thresh_inds = find(percent < tail);
    for ii = 1:z
        threshImg = matches(:,:,ii);
        threshImg(threshImg <= x(thresh_inds(1))) = 0;
        threshImg(threshImg > x(thresh_inds(1))) = 1;
        if length(threshImg(threshImg ~=0)) > 3000
            error('vesicle_detect:bad_threshold','Check parameter "tail".  Too many labled points.');
        end
        matches(:,:,ii) = threshImg;
    end
else
    matches(matches <= thresh) = 0;
    matches(matches > thresh) = 1;
end

%% Filter out non-clustered hits
% Get centroids
cc = bwconncomp(matches(:,:,:));
cc_props = regionprops(cc,'Centroid');
centroids = struct2cell(cc_props);
centroids = cell2mat(centroids');
cc_props = regionprops(cc,'pixelList');

if isempty(centroids)
    % no detections!
    fprintf('Non-empty block, but no detections!')
    labels = zeros(size(cube.data));

    emptyFlag = 1;
end

if ~emptyFlag
    % Fix anisotropy at scale 1 and put into nm
    if data_set == 0
        centroids = bsxfun(@times,centroids,[6,6,30]);
    elseif data_set == 1
        centroids = bsxfun(@times,centroids,[8,8,45]);
    else
        error('unsupported dataset');
    end

    % Compute distances
    D = squareform(pdist(centroids));

    D(D > neighbor_dist) = 0;
    D(D > 0) = 1;

    neighbors = sum(D,2);

    out_clusters = find(neighbors < neighborhood_size);

    for ii = 1:length(out_clusters)
        px = cc_props(out_clusters(ii)).PixelList;
        inds = sub2ind(size(matches),px(:,2),px(:,1),px(:,3));
        matches(inds) = 0;
    end

    %% Output
    se = strel('disk', 4, 0);
    labels = imdilate(matches,se,'same');
end

%Reuse cube volume
off = cube.xyzOffset;
labels = labels(padX+1:end-padX, padY+1:end-padY, padZ+1:end-padZ)* annoId;
cube.setCutout(labels);
cube.setXyzOffset([off+[padX,padY,padZ]]);
save(outFile,'cube','-v7.3')
