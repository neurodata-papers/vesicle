function vesicle_detect_quick(RAMONVol, template, annoId, neighborhood_size, neighbor_dist, thresh, data_set, padX, padY, padZ, outFile)
% Test call
% vesicle_detect_quick(im,'~/code/vesicle/data/vesicle_templates_kasthuri11cc.mat',1, 3,120,1.25,0,50,50,2,'testv.mat')
% Added simple distance requirement

%neighborhood size = 3
%distance = 120
%thresh = 1.25;

% Load data volume
if ischar(RAMONVol)
    load(RAMONVol) %should be saved as cube
else
    cube = RAMONVol;
end

data = cube.data;
tail = []; % used to estimate threshold

%% Check inputs
if ~exist('template','var')
    error('vesicle_detect:param_error','You must provide a template generated by "get_template.m"');
end

%% Load Template
load(template);

%% Run Correlation
[x,y,z] = size(data);

mean_template = mean(patches,3);
[x_template,y_template] = size(mean_template);

matches = zeros(x+x_template-1,y+y_template-1,z);
h = fspecial('log',[x_template y_template],.5);
for ii = 1:z
    % Correlation
    matches(:,:,ii) = normxcorr2(mean_template,data(:,:,ii));
    % LoG
    matches(:,:,ii) = imfilter(imcomplement(matches(:,:,ii)),h,'replicate');
end

% Crop back to image
matches(:,1:floor(y_template/2),:) = [];
matches(1:floor(x_template/2),:,:) = [];
matches(:,end-floor(y_template/2)+1:end,:) = [];
matches(end-floor(x_template/2)+1:end,:,:) = [];


% Threshold
if ~isempty(tail)
    matches(matches<0) = 0;
    [counts,x] = hist(matches(:),128);
    totals = cumsum(counts);
    percent = (totals(end) - totals) ./ totals(end);
    thresh_inds = find(percent < tail);
    for ii = 1:z
        threshImg = matches(:,:,ii);
        threshImg(threshImg <= x(thresh_inds(1))) = 0;
        threshImg(threshImg > x(thresh_inds(1))) = 1;
        if length(threshImg(threshImg ~=0)) > 3000
            error('vesicle_detect:bad_threshold','Check parameter "tail".  Too many labled points.');
        end
        matches(:,:,ii) = threshImg;
    end
else
    matches(matches <= thresh) = 0;
    matches(matches > thresh) = 1;
end

%% Filter out non-clustered hits
% Get centroids
cc = bwconncomp(matches(:,:,:));
cc_props = regionprops(cc,'Centroid');
centroids = struct2cell(cc_props);
centroids = cell2mat(centroids');
cc_props = regionprops(cc,'pixelList');

if isempty(centroids)
    % no detections!
    fprintf('Non-empty block, but no detections!')
    labels = [];
    return;
end
data_set
% Fix anisotropy at scale 1 and put into nm
if data_set == 0
    centroids = bsxfun(@times,centroids,[6,6,30]);
elseif data_set == 1
    centroids = bsxfun(@times,centroids,[8,8,45]);
else
    error('unsupported dataset');
end

% Compute distances
D = squareform(pdist(centroids));

D(D > neighbor_dist) = 0;
D(D > 0) = 1;

neighbors = sum(D,2);

out_clusters = find(neighbors < neighborhood_size);

for ii = 1:length(out_clusters)
    px = cc_props(out_clusters(ii)).PixelList;
    inds = sub2ind(size(matches),px(:,2),px(:,1),px(:,3));
    matches(inds) = 0;
end

%% Output
se = strel('disk', 4, 0);
labels = imdilate(matches,se,'same');

%Reuse cube volume
off = cube.xyzOffset;
labels = labels(padX+1:end-padX, padY+1:end-padY, padZ+1:end-padZ)* annoId;
cube.setCutout(labels);

save(outFile,'cube')


% Temp visualization
%     labels = RAMONVolume(labels,eRAMONDataFormat.dense);
%     labels.setXyzOffset(em_copy.xyzOffset);
%     labels.setResolution(em_copy.resolution);
%     img = RAMONVolume(em_copy.data,eRAMONDataFormat.dense);
%     h = image(img);
%     h.associate(labels);
% Temp visualization
